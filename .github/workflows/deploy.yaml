name: Deploy

on:
  workflow_run:
    workflows: ["Tests"]
    types:
      - completed

  workflow_dispatch:

jobs:
  deploy:
    # Only deploy if Tests workflow for a push to main succeeded
    if: >
      ${{
        github.event.workflow_run.conclusion == 'success' &&
        github.event.workflow_run.event == 'push' &&
        github.event.workflow_run.head_branch == 'main' }}

    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT }}
          script: |
            set -e
            set -o pipefail

            APP_DIR="${VPS_APP_DIR:-$HOME/better-uptime}"
            cd "$APP_DIR"

            echo "=========================================="
            echo "Starting deployment (Redis + PM2)"
            echo "=========================================="

            # ---------- Docker & Docker Compose ----------
            echo "Ensuring Docker is available..."
            if ! command -v docker >/dev/null 2>&1; then
              echo "Docker not found. Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              rm get-docker.sh
            fi

            echo "Ensuring Docker Compose is available..."
            if ! command -v docker compose >/dev/null 2>&1; then
              echo "Docker Compose not found. Installing Docker Compose..."
              sudo apt-get update
              sudo apt-get install -y docker-compose-plugin
            fi

            # Verify Docker is running
            if ! sudo systemctl is-active --quiet docker; then
              echo "Starting Docker service..."
              sudo systemctl start docker
              sudo systemctl enable docker
            fi

            # ---------- Git Pull ----------
            echo "Fetching latest code..."
            git fetch origin
            git checkout main
            git pull origin main

            # ---------- Environment Variables ----------
            echo "Checking environment variables..."
            if [ ! -f ".env" ] && [ ! -f "packages/config/.env" ]; then
              echo "WARNING: .env file not found. Please create one with required environment variables."
              echo "See docker/REDIS_SETUP.md for Redis configuration details."
            fi

            # ---------- Load Node / NVM (for Prisma) ----------
            export NVM_DIR="$HOME/.nvm"
            if [ -s "$NVM_DIR/nvm.sh" ]; then
              . "$NVM_DIR/nvm.sh"
            fi

            # Ensure bashrc exists (pnpm installer expects it)
            [ -f "$HOME/.bashrc" ] || touch "$HOME/.bashrc"

            # ---------- pnpm (for Prisma migrations) ----------
            echo "Ensuring pnpm is available for Prisma migrations..."
            if command -v corepack >/dev/null 2>&1; then
              corepack enable
              corepack prepare pnpm@9 --activate
            elif ! command -v pnpm >/dev/null 2>&1; then
              curl -fsSL https://get.pnpm.io/install.sh | sh -
              export PATH="$HOME/.local/share/pnpm:$PATH"
            fi

            # ---------- Bun (for PM2 services) ----------
            echo "Ensuring Bun is available..."
            export BUN_INSTALL="$HOME/.bun"
            export PATH="$BUN_INSTALL/bin:$PATH"
            if ! command -v bun >/dev/null 2>&1; then
              curl -fsSL https://bun.sh/install | bash
            fi

            # ---------- Install Dependencies ----------
            echo "Installing dependencies..."
            pnpm install --frozen-lockfile

            # ---------- Prisma Migrations ----------
            echo "Running Prisma migrations..."
            pnpm --filter @repo/store prisma:deploy || echo "Prisma migration failed, check logs"
            echo "Generating Prisma Client..."
            pnpm --filter @repo/store prisma:generate || echo "Prisma generate failed, check logs"

            # ---------- Build Application ----------
            echo "Building application..."
            pnpm build

            # ---------- Redis (Manual/External) ----------
            echo "Verifying Redis connection (using manually managed Redis instance)..."
            
            # Install redis-tools if not available (for health check)
            if ! command -v redis-cli >/dev/null 2>&1; then
              echo "Installing redis-tools for health check..."
              sudo apt-get update -qq
              sudo apt-get install -y redis-tools >/dev/null 2>&1 || true
            fi

            # Get Redis connection details from .env
            REDIS_HOST_ENV="localhost"
            REDIS_PORT_ENV="6379"
            REDIS_PASSWORD_ENV=""
            
            if [ -f ".env" ]; then
              REDIS_HOST_ENV=$(grep "^REDIS_HOST=" .env 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" | head -1 || echo "localhost")
              REDIS_PORT_ENV=$(grep "^REDIS_PORT=" .env 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" | head -1 || echo "6379")
              REDIS_PASSWORD_ENV=$(grep "^REDIS_PASSWORD=" .env 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" | head -1 || echo "")
            elif [ -f "packages/config/.env" ]; then
              REDIS_HOST_ENV=$(grep "^REDIS_HOST=" packages/config/.env 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" | head -1 || echo "localhost")
              REDIS_PORT_ENV=$(grep "^REDIS_PORT=" packages/config/.env 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" | head -1 || echo "6379")
              REDIS_PASSWORD_ENV=$(grep "^REDIS_PASSWORD=" packages/config/.env 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" | head -1 || echo "")
            fi

            # Use defaults if empty
            REDIS_HOST_ENV="${REDIS_HOST_ENV:-localhost}"
            REDIS_PORT_ENV="${REDIS_PORT_ENV:-6379}"

            echo "Connecting to Redis at ${REDIS_HOST_ENV}:${REDIS_PORT_ENV}..."

            # Wait for Redis to accept connections (CRITICAL: PM2 must wait)
            echo "Waiting for Redis to accept connections..."
            REDIS_READY=false
            for i in {1..20}; do
              # Try ping with password if available, otherwise without
              if [ -n "$REDIS_PASSWORD_ENV" ]; then
                if redis-cli -h "$REDIS_HOST_ENV" -p "$REDIS_PORT_ENV" -a "$REDIS_PASSWORD_ENV" ping >/dev/null 2>&1; then
                  echo "✓ Redis is accepting connections at ${REDIS_HOST_ENV}:${REDIS_PORT_ENV} (attempt $i)"
                  REDIS_READY=true
                  break
                fi
              else
                if redis-cli -h "$REDIS_HOST_ENV" -p "$REDIS_PORT_ENV" ping >/dev/null 2>&1; then
                  echo "✓ Redis is accepting connections at ${REDIS_HOST_ENV}:${REDIS_PORT_ENV} (attempt $i)"
                  REDIS_READY=true
                  break
                fi
              fi
              echo "Redis not ready yet... retrying ($i/20)"
              sleep 2
            done

            if [ "$REDIS_READY" = false ]; then
              echo "❌ ERROR: Cannot connect to Redis at ${REDIS_HOST_ENV}:${REDIS_PORT_ENV}"
              echo "Please ensure Redis is running and accessible."
              echo "Check Redis status: systemctl status redis (or redis-server)"
              echo "Verify connection: redis-cli -h ${REDIS_HOST_ENV} -p ${REDIS_PORT_ENV} ping"
              exit 1
            fi

            echo "✓ Redis connection verified successfully"

            # ---------- PM2 Services ----------
            echo "Reloading PM2 processes..."
            cd "$APP_DIR"
            pm2 reload ecosystem.config.cjs || pm2 start ecosystem.config.cjs
            pm2 save

            echo "PM2 process status:"
            pm2 status

            # ---------- Health Checks ----------
            echo "Performing health checks..."
            
            # Check if PM2 services are running
            if pm2 list | grep -q "online"; then
              echo "✓ PM2 services are running"
            else
              echo "⚠ Some PM2 services may not be online, check logs"
            fi

            # Show recent PM2 logs
            echo "Recent PM2 logs:"
            pm2 logs --lines 20 --nostream

            # ---------- Cleanup ----------
            echo "Cleaning up unused Docker resources..."
            docker system prune -f || true

            echo "=========================================="
            echo "Deployment completed successfully"
            echo "=========================================="
            echo ""
            echo "Services status:"
            echo "  - Redis: Using manually managed instance at ${REDIS_HOST_ENV}:${REDIS_PORT_ENV}"
            echo "  - PM2: pm2 status"
            echo ""
            echo "Useful commands:"
            echo "  - Redis status: systemctl status redis (or redis-cli -h ${REDIS_HOST_ENV} -p ${REDIS_PORT_ENV} ping)"
            echo "  - PM2 logs: pm2 logs"
            echo "  - Restart PM2: pm2 restart all"
            echo "  - Restart Redis: systemctl restart redis (or your Redis management command)"
